
import pandas as pd
import numpy as np
import numpy_financial as npf
import functions_ELH as fun
import time
import pygad
from operator import add

def Electricity_heater_load(Power, Heating_load):
    """"
    Power in kW
    Heating load in kWh (An array with 8760 hours)
    Efficency set to 95% (Source)
    Output is the new lower heating load that has been taken care of with the electrical heater (array of 8760 hours)
    Electrical load from the electrical heater (array of 8760 hours)
    """
    
    Efficency = 0.95 # Depending on source but assumed to be 95% (Source  "UKSupplyCurve") #between 90-100%
    Electricity_load = np.zeros(8760)
    New_heating_load = np.zeros(8760)
    for count, load in enumerate(Heating_load): #goes through the array with the load demand
        if load < Power:                        #if the load is less then the power of the electrical heater
            Electricity_load[count] = load/Efficency    #Electricity load is increase by the load divided by the efficency
            New_heating_load[count] = 0                 #as the load was lower then the power zero heating load is left this hour
        elif load > Power:
            Electricity_load[count] = Power/Efficency   # When the load is higher than the Power of the electrical heater, the new electricty this hour is the power divided by the efficency
            New_heating_load[count] = load - Power #The heat load this hour is the load minus the power that was removed by the electrical heater

    return Electricity_load, New_heating_load

def fitness_func_NPV(solution, solution_idx):
    """
    Returns the NPV value (used as fitness value in GA)
    """

    ESS_capacity, ESS_power, ELH_power = solution[0], solution[1], solution[2]
    
    cashflow_each_year = [-((ESS_capacity_cost*ESS_capacity) + (ESS_power*ESS_power_cost) + ELH_power*ELH_power_cost)] #First Year is just capex cost and negative as it is a cost
    ESS_capacity_year = 0 #Starts with zero energy in the storage

    Electricity_heating_load = Electricity_heater_load(Power=ELH_power, Heating_load = Heating_hourly_use) #array first is the electricity load from ELH, and second array is the new Heating load
    Energy_hourly_use = Electricity_load + Electricity_heating_load[0] #adds the electricity load with the ELH electricity load

    for year in range(1,11): # starts at year 1 and includes year 10 as the lifetime of ESS is 10 years (battery) 
        
        Schedule = fun.ESS_schedule(ESS_capacity_size=ESS_capacity, ESS_power=ESS_power,
                                        Energy_hourly_cost=Energy_hourly_cost,
                                        Average_median_cost_day=Average_median_cost_day,
                                        Energy_hourly_use=Energy_hourly_use,
                                        ESS_discharge_eff=ESS_discharge_eff, ESS_charge_eff=ESS_charge_eff, Year = year, ESS_capacity_prev_year= ESS_capacity_year)
    
                
        #This calculates the cost of buying and using the ESS storage, as well as the profits of sell energy from it, and inputs that into an array for each year.
        #This does not include the energy used by the user. (Aka the load demand), but the schedule is designed from that schedule
        New_schedule = Schedule[0]
        ESS_capacity_year = Schedule[1]  #Inputs the preveious years ess capacity to next years
        Peak_diff = fun.Peak_diff(Electricty_usage_pre_schedule = Energy_hourly_use, Schedule = Schedule[0])
        cashflow_each_year.append(fun.cashflow_yearly_NPV(schedule_load = New_schedule[:, 0], schedule_discharge = New_schedule[:,1], demand_cost = Energy_hourly_cost,
                                                        Variable_O_and_M_cost = Variable_ESS_O_and_M_cost, Fixed_O_and_M_cost = Fixed_ESS_O_and_M_cost,
                                                        ESS_power = ESS_power,  ELH_OPEX = ELH_OPEX, ELH_power= ELH_power, Gas_cost = Gas_cost,
                                                        Heating_demand_after_ELH = Electricity_heating_load[1], Heating_demand_pre = Heating_load, Peak_diff = Peak_diff, Peak_diff_cost = Peak_cost))

    fitness = fun.Fitness_NPV(discount_rate = Discount_rate, cashflows = cashflow_each_year)
    return fitness


def fitness_func_LCOS(solution, solution_idx):
    ESS_capacity, ESS_power, ELH_power = solution[0], solution[1], solution[2]
    CAPEX = ((ESS_capacity_cost*ESS_capacity) + (ESS_power*ESS_power_cost) + ELH_power*ELH_power_cost) 
    Cost_yearly = []
    Energy_yearly = []
    ESS_capacity_year = 0 #Starts with zero energy in the storage
    
    Electricity_heating_load = Electricity_heater_load(Power=ELH_power, Heating_load = Heating_hourly_use) #array first is the electricity load from ELH, and second array is the new Heating load

    Energy_hourly_use = Electricity_load + Electricity_heating_load[0] #adds the electricity load with the ELH electricity load
    for year in range(1,11): # starts at year 1 and includes year 10 as the lifetime of ESS is 10 years (battery)
        
        Schedule = fun.ESS_schedule(ESS_capacity_size=ESS_capacity, ESS_power=ESS_power,
                                        Energy_hourly_cost=Energy_hourly_cost,
                                        Average_median_cost_day=Average_median_cost_day,
                                        Energy_hourly_use=Energy_hourly_use,
                                        ESS_discharge_eff=ESS_discharge_eff, ESS_charge_eff=ESS_charge_eff, Year = year, ESS_capacity_prev_year= ESS_capacity_year)
    
                
        #This calculates the cost of buying and using the ESS storage, as well as the profits of sell energy from it, and inputs that into an array for each year.
        #This does not include the energy used by the user. (Aka the load demand), but the schedule is designed from that schedule
        New_schedule = Schedule[0]
        ESS_capacity_year = Schedule[1]  #Inputs the preveious years ess capacity to next years
        Cost_yearly.append(fun.Cost_yearly_LCOS(schedule_load = New_schedule[:,0], schedule_discharge = New_schedule[:,1], demand_cost = Energy_hourly_cost,
                             Fixed_O_and_M_cost = Fixed_ESS_O_and_M_cost, Variable_O_and_M_cost = Variable_ESS_O_and_M_cost, ESS_power = ESS_power, ELH_OPEX = ELH_OPEX, ELH_power= ELH_power))
        
        Energy_yearly.append(np.sum(New_schedule[:,1]))

    fitness = fun.Fittnes_LCOS(discount_rate = Discount_rate, CAPEX = CAPEX, Yearly_cost = Cost_yearly, Yearly_energy_out = Energy_yearly)
    return -fitness #returns LCOS in Euro/kWh, Negative as it wants to maximize it


def callback_gen(ga_instance):
    print("Generation : ", ga_instance.generations_completed)
    print("Fitness of the best solution :", ga_instance.best_solution()[1])
    


#--------------Read price data for electricity and sets it up into hourly and daily average------------

Electricity_price_read = np.genfromtxt("os-eur17.csv", delimiter=",")  # Prices in EUR/MWh
El_cost_year = []
El_cost_average_day = []

for i in range(365):
    for k in Electricity_price_read[i][0:24]:
        El_cost_year.append((k/1000)*1.11) #Prices in Euro/kWh, by dividing by 1000, times 1.1 to get 2022 euro values
          
    El_cost_average_day.append(((Electricity_price_read[i][24])/1000)*1.1)  #Prices in Euro/kWh that is why we are dividing by 1000, times 1.1 to get 2022 values


# --------------------Read load data for each hour both heating and electrical load---------
Load_data_read = pd.read_csv("Load_data_electricit_heating_2017.csv", header=0) #Takes values from January
Electricity_load_pd = Load_data_read["Electricty [kW]"]
Heating_load_pd = Load_data_read["Heating demand [kW]"]

Heating_load = np.zeros(8760) #in kWh
Electricity_load = np.zeros(8760) #in kWh

for count, i in enumerate(Heating_load_pd):
    Heating_load[count] = i

for count, i in enumerate(Electricity_load_pd):
    Electricity_load[count] = i


# -----------------------For Schedule inputs-------------------------

Energy_hourly_cost = np.array(El_cost_year)     #Prices in Euro/kWh
Average_median_cost_day = np.array(El_cost_average_day) 
Electricity_hourly_use = np.array(Electricity_load)
Heating_hourly_use = np.array(Heating_load)
ESS_charge_eff = 0.9
ESS_discharge_eff = 0.9

# Important to note that the maximum SoC for the battery is calculated in the schedule function

# ------------------------For NPV/LCOE inputs --------------------------
Lifetime_battery = 10  # in years
ESS_capacity_cost = 427.31   # in Euro(2022) per kWh (CAPEX) all cost included
ESS_power_cost = 1710.2  # in Euro(2022) per kW (all cost include)
Fixed_ESS_O_and_M_cost = 4.19  # in Euro(2022) per kW-year
Variable_ESS_O_and_M_cost = 0.488/1000 # in Euro(2022) per kWh-year 
Discount_rate = 0.08 #8 percent
ELH_power_cost = 331.2  # In Euro(2022) per kW "UKSupplyCurve" #Lifetime said to be 15 years
ELH_OPEX = 1.5 # In euro(2022) per kW-year
Gas_cost = (30/1.1218)/293.07106944 #Euro/kWh   #1 mmBTU = 293.07106944 kWh, Gas cost 30 usd per million btu, change to euro: 1 euro is 1.1218 USD, 
                    #https://www.iea.org/data-and-statistics/charts/natural-gas-prices-in-europe-asia-and-the-united-states-jan-2020-february-2022
Peak_cost = 5.92/1.1218 #5.92 dollar (2022) per kW (max per month) change to euro: 1 euro is 1.1218 USD january 1 2022

### ----------------------Preparing other varuables-----------------------

fitness_function = fitness_func_NPV  #CHANGE BETWEEN LCOS OR NPV AS FITNESS FUNCTION

sol_per_pop = 20         #Number of solutions per population, Comparable to "agents in FF"
num_generations = 5     #number of generation to run the algorithm
num_parents_mating = int(sol_per_pop/2)     #number of solutions that will be mating (10% of total solutions used each generation)
init_range_low = 0.1                        #lowest value starting solutions can take
init_range_high = 2000                      #highest value starting solutions can take

parent_selection_type = "sss"               #Method choice for how to pick parent, can be: [sss, rws, sus, rank, random, tournament]
keep_parents = -1                           #Keeps all parents into the next generation (this is in order to not forget good solutions)

crossover_type = "uniform"      #method to crossover the genetics between the two parents, can be [singel_point, two_points, uniform, scattered, ]
crossover_probability = 0.8     #How likely it is for a parent to do a crossover, 0.8 is equal to 80%

mutation_type = "random"        #what operation the mutation will take, can be [random, swap, adaptive]
mutation_probability=0.2        # 10 percent chance of mutation operation to happen for a solution
gene_space = [[0, 10000], [0, np.max(np.array(list(map(add,Electricity_hourly_use, Heating_hourly_use))))],[0.1, np.max(Heating_hourly_use)]]

#The gene_space is the search space for the capacity, ess_power and ELH_power, where the maximum is the max value found in the array as it will never have to be higher than that.

#It should be implemented that the maximum power the solution can take should be dependent on the max value from the load data.

#-----------------------------Set up ga-------------------------------------
ga_instance = pygad.GA(num_generations=num_generations,
                       allow_duplicate_genes= True,
                       num_parents_mating=num_parents_mating,
                       fitness_func=fitness_function,
                       sol_per_pop=sol_per_pop,
                       num_genes=3,
                       gene_type = np.float64,
                       init_range_low=init_range_low,
                       init_range_high=init_range_high,
                       parent_selection_type=parent_selection_type,
                       keep_parents=keep_parents,
                       #callback_generation=callback_gen,
                       crossover_type=crossover_type,
                       mutation_type=mutation_type,
                       mutation_probability = mutation_probability,
                       gene_space=gene_space,
                       #stop_criteria = "saturate_7",    #Stop the algorithm if the same fitness value is given for 7 consectuive generations
                       save_solutions=False) 



#------------------------Gets the average cost for each day, and the hourly cost at each hour during the year------------------------


start = time.time()
ga_instance.run()

end = time.time()

solution, solution_fitness, solution_idx = ga_instance.best_solution()
print("Parameters of the best solution : {solution}".format(solution=solution))
if fitness_function == fitness_func_LCOS:
    print("Fitness value of the best solution LCOS = {solution_fitness}".format(solution_fitness = -solution_fitness), "Euro/kWh")
elif fitness_function == fitness_func_NPV:
    print("Fitness value of the best solution NPV = {solution_fitness}".format(solution_fitness = solution_fitness),"Euro")
print("Index of the best solution : {solution_idx}".format(solution_idx=solution_idx))

print(abs(start-end))
#ga_instance.plot_fitness() #save solutions have to be True to get these out
#ga_instance.plot_genes()